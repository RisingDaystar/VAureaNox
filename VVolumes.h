
/*
Copyright (c) 2017-2018, Alessandro Berti
All rights reserved.

Open Software License ("OSL") v 3.0

This Open Software License (the "License") applies to any original work of
authorship (the "Original Work") whose owner (the "Licensor") has placed the
following licensing notice adjacent to the copyright notice for the Original
Work:

Licensed under the Open Software License version 3.0

1) Grant of Copyright License. Licensor grants You a worldwide, royalty-free,
non-exclusive, sublicensable license, for the duration of the copyright, to do
the following:

  a) to reproduce the Original Work in copies, either alone or as part of a
  collective work;

  b) to translate, adapt, alter, transform, modify, or arrange the Original
  Work, thereby creating derivative works ("Derivative Works") based upon the
  Original Work;

  c) to distribute or communicate copies of the Original Work and Derivative
  Works to the public, with the proviso that copies of Original Work or
  Derivative Works that You distribute or communicate shall be licensed under
  this Open Software License;

  d) to perform the Original Work publicly; and

  e) to display the Original Work publicly.

2) Grant of Patent License. Licensor grants You a worldwide, royalty-free,
non-exclusive, sublicensable license, under patent claims owned or controlled
by the Licensor that are embodied in the Original Work as furnished by the
Licensor, for the duration of the patents, to make, use, sell, offer for sale,
have made, and import the Original Work and Derivative Works.

3) Grant of Source Code License. The term "Source Code" means the preferred
form of the Original Work for making modifications to it and all available
documentation describing how to modify the Original Work. Licensor agrees to
provide a machine-readable copy of the Source Code of the Original Work along
with each copy of the Original Work that Licensor distributes. Licensor
reserves the right to satisfy this obligation by placing a machine-readable
copy of the Source Code in an information repository reasonably calculated to
permit inexpensive and convenient access by You for as long as Licensor
continues to distribute the Original Work.

4) Exclusions From License Grant. Neither the names of Licensor, nor the names
of any contributors to the Original Work, nor any of their trademarks or
service marks, may be used to endorse or promote products derived from this
Original Work without express prior permission of the Licensor. Except as
expressly stated herein, nothing in this License grants any license to
Licensor's trademarks, copyrights, patents, trade secrets or any other
intellectual property. No patent license is granted to make, use, sell, offer
for sale, have made, or import embodiments of any patent claims other than the
licensed claims defined in Section 2. No license is granted to the trademarks
of Licensor even if such marks are included in the Original Work. Nothing in
this License shall be interpreted to prohibit Licensor from licensing under
terms different from this License any Original Work that Licensor otherwise
would have a right to license.

5) External Deployment. The term "External Deployment" means the use,
distribution, or communication of the Original Work or Derivative Works in any
way such that the Original Work or Derivative Works may be used by anyone
other than You, whether those works are distributed or communicated to those
persons or made available as an application intended for use over a network.
As an express condition for the grants of license hereunder, You must treat
any External Deployment by You of the Original Work or a Derivative Work as a
distribution under section 1(c).

6) Attribution Rights. You must retain, in the Source Code of any Derivative
Works that You create, all copyright, patent, or trademark notices from the
Source Code of the Original Work, as well as any notices of licensing and any
descriptive text identified therein as an "Attribution Notice." You must cause
the Source Code for any Derivative Works that You create to carry a prominent
Attribution Notice reasonably calculated to inform recipients that You have
modified the Original Work.

7) Warranty of Provenance and Disclaimer of Warranty. Licensor warrants that
the copyright in and to the Original Work and the patent rights granted herein
by Licensor are owned by the Licensor or are sublicensed to You under the
terms of this License with the permission of the contributor(s) of those
copyrights and patent rights. Except as expressly stated in the immediately
preceding sentence, the Original Work is provided under this License on an "AS
IS" BASIS and WITHOUT WARRANTY, either express or implied, including, without
limitation, the warranties of non-infringement, merchantability or fitness for
a particular purpose. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL WORK
IS WITH YOU. This DISCLAIMER OF WARRANTY constitutes an essential part of this
License. No license to the Original Work is granted by this License except
under this disclaimer.

8) Limitation of Liability. Under no circumstances and under no legal theory,
whether in tort (including negligence), contract, or otherwise, shall the
Licensor be liable to anyone for any indirect, special, incidental, or
consequential damages of any character arising as a result of this License or
the use of the Original Work including, without limitation, damages for loss
of goodwill, work stoppage, computer failure or malfunction, or any and all
other commercial damages or losses. This limitation of liability shall not
apply to the extent applicable law prohibits such limitation.

9) Acceptance and Termination. If, at any time, You expressly assented to this
License, that assent indicates your clear and irrevocable acceptance of this
License and all of its terms and conditions. If You distribute or communicate
copies of the Original Work or a Derivative Work, You must make a reasonable
effort under the circumstances to obtain the express assent of recipients to
the terms of this License. This License conditions your rights to undertake
the activities listed in Section 1, including your right to create Derivative
Works based upon the Original Work, and doing so without honoring these terms
and conditions is prohibited by copyright law and international treaty.
Nothing in this License is intended to affect copyright exceptions and
limitations (including "fair use" or "fair dealing"). This License shall
terminate immediately and You may no longer exercise any of the rights granted
to You by this License upon your failure to honor the conditions in Section
1(c).

10) Termination for Patent Action. This License shall terminate automatically
and You may no longer exercise any of the rights granted to You by this
License as of the date You commence an action, including a cross-claim or
counterclaim, against Licensor or any licensee alleging that the Original Work
infringes a patent. This termination provision shall not apply for an action
alleging patent infringement by combinations of the Original Work with other
software or hardware.

11) Jurisdiction, Venue and Governing Law. Any action or suit relating to this
License may be brought only in the courts of a jurisdiction wherein the
Licensor resides or in which Licensor conducts its primary business, and under
the laws of that jurisdiction excluding its conflict-of-law provisions. The
application of the United Nations Convention on Contracts for the
International Sale of Goods is expressly excluded. Any use of the Original
Work outside the scope of this License or after its termination shall be
subject to the requirements and penalties of copyright or patent law in the
appropriate jurisdiction. This section shall survive the termination of this
License.

12) Attorneys' Fees. In any action to enforce the terms of this License or
seeking damages relating thereto, the prevailing party shall be entitled to
recover its costs and expenses, including, without limitation, reasonable
attorneys' fees and costs incurred in connection with such action, including
any appeal of such action. This section shall survive the termination of this
License.

13) Miscellaneous. If any provision of this License is held to be
unenforceable, such provision shall be reformed only to the extent necessary
to make it enforceable.

14) Definition of "You" in This License. "You" throughout this License,
whether in upper or lower case, means an individual or a legal entity
exercising rights under, and complying with all of the terms of, this License.
For legal entities, "You" includes any entity that controls, is controlled by,
or is under common control with you. For purposes of this definition,
"control" means (i) the power, direct or indirect, to cause the direction or
management of such entity, whether by contract or otherwise, or (ii) ownership
of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial
ownership of such entity.

15) Right to Use. You may use the Original Work in all ways not otherwise
restricted or conditioned by this License or by law, and Licensor promises not
to interfere with or be responsible for such uses by You.

16) Modification of This License. This License is Copyright Â© 2005 Lawrence
Rosen. Permission is granted to copy, distribute, or communicate this License
without modification. Nothing in this License permits You to modify this
License as applied to the Original Work or to Derivative Works. However, You
may modify the text of this License and copy, distribute or communicate your
modified version (the "Modified License") and apply it to other original works
of authorship subject to the following conditions: (i) You may not indicate in
any way that your Modified License is the "Open Software License" or "OSL" and
you may not use those names in the name of your Modified License; (ii) You
must replace the notice specified in the first paragraph above with the notice
"Licensed under <insert your license name here>" or with a notice of your own
that is not confusingly similar to the notice in this License; and (iii) You
may not claim that your original works are open source software unless your
Modified License has been approved by Open Source Initiative (OSI) and You
comply with its license review and certification process.
*/


#ifndef _VVOLUMES_H
#define _VVOLUMES_H

#include "VAureaNox.h"

using namespace vnx;

//Personalizzabile
struct vvo_shadered : public VVolume {
	std::function<float(const ygl::vec3f& p, ygl::vec3f& ep, const VNode* tref) > shader = nullptr;
	vvo_shadered(std::string ids, VMaterial* mat, std::function<float(const ygl::vec3f& p, ygl::vec3f& ep, const VNode* tref) > ftor) { id = ids; material = mat; shader = ftor; }

	inline const char* type(){return "vvo_shadered";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		float dv = ygl::maxf;
		if (shader != nullptr) { dv = shader(p, ep, this); }
		dv+=eval_displacement(ep);
		dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
///

struct vvo_sd_plane : public VVolume {
	ygl::vec4f n = ygl::vec4f{ 0,1,0,1 };
	vvo_sd_plane(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_plane(std::string ids, VMaterial* mat, ygl::vec4f nv) { id = ids; material = mat; n = nv; }

	inline const char* type(){return "vvo_sd_plane";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;

        //DUAL NUMBERS
        /*
        auto da_dom = dual3Dom<float>(ep);
        auto da = (dot(da_dom,dual3Dom<float>({n.x,n.y,n.z})) - dual3<float>(1.0f/n.w))*dual3<float>(std::min(scale.x, std::min(scale.y, scale.z)));
        return VResult{this,material,da.real,da.dual,p,ep};
        */

		float dv = ygl::dot(ep, ygl::normalize(ygl::vec3f{ n.x,n.y,n.z })) + (1.0 / n.w);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };

	}
};
struct vvo_sd_sphere : public VVolume {
	float r = 1.0f;
	vvo_sd_sphere(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_sphere(std::string ids, VMaterial* mat, float rv) { id = ids; material = mat; r = rv; }

	inline const char* type(){return "vvo_sd_sphere";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		float dv = ygl::length(ep) - r;
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_box : public VVolume {
	ygl::vec3f b = one3f;
	vvo_sd_box(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_box(std::string ids, VMaterial* mat, ygl::vec3f bv) { id = ids; material = mat; b = bv; }
	vvo_sd_box(std::string ids, VMaterial* mat, float bv) { id = ids; material = mat; b = {bv,bv,bv}; }

	inline const char* type(){return "vvo_sd_box";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
        vec3f d = abs(ep) - b;
        float dv = length(vnx::vgt(d,zero3f)) + std::min(std::max(d.x,std::max(d.y,d.z)),0.0f);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };

	}
};
struct vvo_sd_ellipsoid : public VVolume {
	ygl::vec3f r = one3f;
	vvo_sd_ellipsoid(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_ellipsoid(std::string ids, VMaterial* mat, ygl::vec3f rv) { id = ids; material = mat; r = rv; }

	inline const char* type(){return "vvo_sd_ellipsoid";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		float dv = (length(ep / r) - 1.0) * std::min(std::min(r.x, r.y), r.z);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_cylinder : public VVolume {
	ygl::vec2f h = one2f;
	vvo_sd_cylinder(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_cylinder(std::string ids, VMaterial* mat, ygl::vec2f hv) { id = ids; material = mat; h = hv; }

	inline const char* type(){return "vvo_sd_cylinder";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		ygl::vec2f d = vabs(ygl::vec2f{length(ygl::vec2f{ ep.x,ep.z }), ep.y}) - h;
		float dv = std::min(std::max(d.x, d.y), 0.0f) + length(vnx::vgt(d, ygl::zero2f));
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_capsule : public VVolume {
	float r = 1.0f;
	ygl::vec3f a = one3f;
	ygl::vec3f b = one3f;
	vvo_sd_capsule(std::string ids, VMaterial* mat) { id = ids; r = 1.0f; a = one3f; b = one3f; }
	vvo_sd_capsule(std::string ids, VMaterial* mat, float rv, ygl::vec3f av, ygl::vec3f bv) { id = ids; r = rv; a = av; b = bv; }

	inline const char* type(){return "vvo_sd_capsule";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		ygl::vec3f pa = ep - a, ba = b - a;
		float h = ygl::clamp(dot(pa, ba) / dot(ba, ba), 0.0f, 1.0f);
		float dv = length(pa - ba*h) - r;
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_hex_prism : public VVolume {
	ygl::vec2f h = one2f;
	vvo_sd_hex_prism(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_hex_prism(std::string ids, VMaterial* mat, ygl::vec2f hv) { id = ids; material = mat; h = hv; }

	inline const char* type(){return "vvo_sd_hex_prism";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		ygl::vec3f q = vabs(ep);
		auto dv = std::max(q.z - h.y, std::max((q.x*0.866025f + q.y*0.5f), q.y) - h.x);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_tri_prism : public VVolume {
	ygl::vec2f h = one2f;
	vvo_sd_tri_prism(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_tri_prism(std::string ids, VMaterial* mat, ygl::vec2f hv) { id = ids; material = mat; h = hv; }

	inline const char* type(){return "vvo_sd_tri_prism";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;
		ygl::vec3f q = vabs(ep);
		auto dv = std::max(q.z - h.y, std::max(q.x*0.866025f + ep.y*0.5f, -ep.y) - h.x*0.5f);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};
struct vvo_sd_capped_cone : public VVolume {
	ygl::vec3f c = one3f;
	vvo_sd_capped_cone(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_capped_cone(std::string ids, VMaterial* mat, ygl::vec3f cv) { id = ids; material = mat; c = cv; }

	inline const char* type(){return "vvo_sd_capped_cone";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;

		ygl::vec2f q = ygl::vec2f{ygl::length(ygl::vec2f{ ep.x,ep.z }), ep.y};
		ygl::vec2f v = ygl::vec2f{c.z*c.y / c.x, -c.z};
		ygl::vec2f w = v - q;
		ygl::vec2f vv = ygl::vec2f{dot(v, v), v.x*v.x};
		ygl::vec2f qv = ygl::vec2f{dot(v, w), v.x*w.x};
		ygl::vec2f d = vgt(qv, ygl::zero2f)*qv / vv;
		auto dv = sqrt(dot(w, w) - std::max(d.x, d.y)) * sign(std::max(q.y*v.x - q.x*v.y, w.y));
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};


struct vvo_sd_pyramid4 : public VVolume {
    ygl::vec3f h = {1,1,1};
	vvo_sd_pyramid4(std::string ids, VMaterial* mat) { id = ids; material = mat; }
	vvo_sd_pyramid4(std::string ids, VMaterial* mat, ygl::vec3f hv) { id = ids; material = mat; h = hv; }

	inline const char* type(){return "vvo_sd_pyramid4";}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;

        ygl::vec3f d = vabs(ep - vec3f{0,-2.0*h.z,0}) - vec3f{2.0*h.z,2.0*h.z,2.0*h.z};
		auto bdv = std::min(vnx::max_element<float>(d), 0.0f) + ygl::length(vgt(d, ygl::zero3f));

        float dv = 0.0;
        dv = std::max( dv, std::abs( dot(ep, vec3f{ -h.x, h.y, 0 }) ));
        dv = std::max( dv, std::abs( dot(ep, vec3f{  h.x, h.y, 0 }) ));
        dv = std::max( dv, std::abs( dot(ep, vec3f{  0, h.y, h.x }) ));
        dv = std::max( dv, std::abs( dot(ep, vec3f{  0, h.y,-h.x }) ));
        float octa = dv - h.z;
        dv = std::max(-bdv,octa);
		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}

};

struct vvo_sd_diamond : public VVolume {

	vvo_sd_diamond(std::string ids, VMaterial* mat) { id = ids; material = mat; }

	inline const char* type(){return "vvo_sd_diamond";}

	mat3f rot_y(float a) {
		float c = cos(a);
		float s = sin(a);
		return mat3f{
		{ c, 0.0, s },
		{ 0.0, 1.0, 0.0 },
		{ -s, 0.0, c }
		};
	}

	virtual inline void eval(const ygl::vec3f& p,VResult& res) {
		ygl::vec3f ep = ygl::transform_point_inverse(_frame, p) / scale;

		float dv = minf;
		vec3f point_0 = rot_y(ygl::pif / 4.0)*ep;
		vec3f point_1 = rot_y(ygl::pif / 8.0 + ygl::pif / 16.0)*ep;
		vec3f point_2 = rot_y(ygl::pif / 8.0 - ygl::pif / 16.0)*ep;
		vec3f point_3 = rot_y(-ygl::pif / 8.0 + ygl::pif / 16.0)*ep;
		vec3f point_4 = rot_y(-ygl::pif / 8.0 - ygl::pif / 16.0)*ep;
		vec3f temp;
		point_1 = vec3f{std::abs(point_1.x), -point_1.y, std::abs(point_1.z)};
		point_2 = vec3f{std::abs(point_2.x), -point_2.y, std::abs(point_2.z)};
		point_3 = vec3f{std::abs(point_3.x), -point_3.y, std::abs(point_3.z)};
		point_4 = vec3f{std::abs(point_4.x), -point_4.y, std::abs(point_4.z)};
		temp = normalize(vec3f{1.0, 1.5f, 1.0});
		dv = std::max(dot(vabs(ep), temp) - 0.5f*1.5f, dv);
		dv = std::max(dot(vabs(point_0), temp) - 0.5f*1.5f, dv);
		dv = std::max(ep.y - 0.5f, dv);
		temp = normalize(vec3f{1.0, 1.4f, 1.0});
		dv = std::max(dot(point_1, temp) - 0.762f, dv);
		dv = std::max(dot(point_2, temp) - 0.762f, dv);
		dv = std::max(dot(point_3, temp) - 0.762f, dv);
		dv = std::max(dot(point_4, temp) - 0.762f, dv);
		point_1 = vec3f{point_1.x, -point_1.y, point_1.z};
		point_2 = vec3f{point_2.x, -point_2.y, point_2.z};
		point_3 = vec3f{point_3.x, -point_3.y, point_3.z};
		point_4 = vec3f{point_4.x, -point_4.y, point_4.z};
		temp = normalize(vec3f{1.0, 1.25, 1.0});
		dv = std::max(dot(point_1, temp) - 0.804f, dv);
		dv = std::max(dot(point_2, temp) - 0.804f, dv);
		dv = std::max(dot(point_3, temp) - 0.804f, dv);
		dv = std::max(dot(point_4, temp) - 0.804f, dv);
		point_1 = rot_y(ygl::pif / 8.0)*ep;
		point_2 = rot_y(-ygl::pif / 8.0)*ep;
		point_1 = vec3f{std::abs(point_1.x), point_1.y, std::abs(point_1.z)};
		point_2 = vec3f{std::abs(point_2.x), point_2.y, std::abs(point_2.z)};
		temp = normalize(vec3f{1.0f, 2.5f, 1.0f});
		dv = std::max(dot(point_1, temp) - 0.69f, dv);
		dv = std::max(dot(point_2, temp) - 0.69f, dv);

		dv+=eval_displacement(ep);
        dv*=min_element(scale);
		res = VResult{ this,this,material,material,dv,dv,zero3f,p,ep };
	}
};



#endif
